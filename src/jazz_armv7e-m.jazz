
export
fn __jazz_poly_compress1(reg u32 des, reg u32 src){

    reg u32[8] a;
    reg u32 b;

    inline int i j;

    // 2580335 = round(2^33 / 3329)
    b = #MOV(2580335 % 65536);
    b = #MOVT(b, 2580335 / 65536);

    for i = 0 to 32 {

        for j = 0 to 8 {
            a[j] = (32s)(u16)[src + j * 2];
        }
        src += 8 * 2;

        for j = 0 to 8 {
            a[j] = #SMMULR(a[j], b);
            a[j] = #UBFX(a[j], 0, 1);
        }

        for j = 1 to 8 {
            a[0] |= (a[j] << j);
        }

        (u8)[des] = (8u)a[0];
        des += 1;

    }

}

export
fn __jazz_poly_compress4(reg u32 des, reg u32 src){

    reg u32[4] a;
    reg u32 b;

    inline int i j;

    b = #MOV(20642679 % 65536);
    b = #MOVT(b, 20642679 / 65536);

    for i = 0 to 64 {

        for j = 0 to 4 {
            a[j] = (32s)(u16)[src + j * 2];
        }
        src += 4 * 2;

        for j = 0 to 4 {
            a[j] = #SMMULR(a[j], b);
            a[j] = #UBFX(a[j], 0, 4);
        }

        for j = 1 to 4 {
            a[0] |= a[j] << (4 * j);
        }

        (u16)[des] = (16u)a[0];
        des += 2;

    }

}

export
fn __jazz_poly_compress10(reg u32 des, reg u32 src){

    reg u32[4] a;
    reg u32 b;

    b = #MOV(1321131424 % 65536);
    b = #MOVT(b, 1321131424 / 65536);

    inline int i j;

    for i = 0 to 64 {

        for j = 0 to 4 {
            a[j] = (32s)(u16)[src + j * 2];
        }
        src += 4 * 2;

        for j = 0 to 4 {
            a[j] = #SMMULR(a[j], b);
            a[j] = #UBFX(a[j], 0, 10);
        }

        for j = 1 to 4 {
            a[0] |= a[j] << (10 * j);
        }
        a[3] >>= 2;

        [des] = a[0];
        (u8)[des + 4] = (8u)a[3];
        des += 5;

    }

}

